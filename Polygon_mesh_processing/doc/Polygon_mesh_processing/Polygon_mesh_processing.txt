namespace CGAL {
/*!
\mainpage User Manual
\anchor Chapter_PolygonMeshProcessing

\cgalAutoToc
\author SÃ©bastien Loriot, Jane Tournois, Ilker %O. Yaz

\image html neptun_head.png
\image latex neptun_head.png
<BR>

\section PMPIntroduction Introduction

This package implements a collection of methods and classes for polygon mesh processing,
ranging from basic operations on simplices, to complex geometry processing algorithms.
The implementation of this package mainly follows algorithms and references
given in Botsch et al.'s book on polygon mesh processing \cgalCite{botsch2010PMP}.

\subsection PMPDef Polygon Mesh
A \a polygon \a mesh is a consistent and orientable surface mesh, that can have a boundary.
The \a faces are simple polygons.
The \a edges are segments. Each edge is shared by two faces, and connects two \a vertices.
A polygon mesh can have any number of connected components, and also some self-intersections.

\subsection PMPAPI API
This package follows the BGL API described in \ref chapterBGL.
It can thus be used either with `Polyhedron_3`, `Surface_mesh`, or
any graph following the BGL requirements. Each function or class of this package
gives precisions on the requirements on the polygon mesh.

BGL \ref namedparameters are used to deal with optional parameters.

\subsection PMPOutline Outline
The first type of algorithms described in this manual is about \ref PMPMeshing algorithms, including triangulation of non triangulated
meshes, refinement and optimization by fairing of triangulated surface meshes.
The second section lists the available, \ref PMPHoleFilling algorithms, which can possibly be combined with refinement and fairing.
Section \ref PMPPredicates gives a list of predicates that can be evaluated on the processed polygon
mesh, including point location and self intersection tests.
Tools for checking or fixing the \ref PMPOrientation are then described.
The following section deals with \ref PMPRepairing of polygon meshes and polygon soups.
\ref PMPNormalComp at vertices and on faces of a polygon mesh are then listed.
Section \ref PMPSlicer describes a class that provides an operator able to compute intersections
of the same polygon mesh with arbitrary planes.
The last section of this manual deals with methods to compute \ref PMPConnectedComponents
of a polygon mesh, and discard the smallest ones.


****************************************
\section PMPMeshing Meshing
\subsection API

A surface patch can be refined by inserting new vertices and flipping edges to get a valid triangulation.
Using a criterion presented in \cgalCite{Lipea2003FillingHoles},
the density of triangles near the boundary of the patch is approximated by the refinement function.
The validity of the mesh is kept by flipping edges.
An edge is flipped only if the opposite edge does not exist in the original mesh
and if no degenerate triangles are produced.

A region of the surface mesh (e.g. the refined region) can be faired to obtain a tangentially continuous and smooth patch.
The fairing step minimizes a linear bi-Laplacian system with boundary constraints,
described in \cgalCite{Botsch2008OnLinearVariational}.
The visual results of aforementioned steps can be seen in \cgalFigureRef{Mech_steps} (c and d).

Refinement and fairing functions can be applied to an arbitrary region on a mesh , using :
- `CGAL::Polygon_mesh_processing::refine()` : given a set of facets on a mesh, refines the region.
- `CGAL::Polygon_mesh_processing::fair()` : given a set of vertices on a mesh, fairs the region.


Many algorithms only work for meshes in which all the faces have the same number of vertices,
or even only for triangle meshes. Hence, one may want to triangulate a polygon mesh
with any types of polygons as faces.
This package provides the function `CGAL::Polygon_mesh_processing::triangulate_faces()`
that triangulates all faces of the input polygon mesh.


\subsection MeshingExamples Meshing Examples

\subsubsection MeshingExample_1 Refine and Fair a Region on a Polygon Mesh

The following example shows how to use the functions `CGAL::Polygon_mesh_processing::refine()`
and `CGAL::Polygon_mesh_processing::fair()` for some selected regions on the input polygon mesh.

\cgalExample{Polygon_mesh_processing/refine_fair_example.cpp}

\todo code : fair() makes the mesh disappear in this example

\subsubsection MeshingExample_2 Triangulate a Polygon Mesh

Triangulating a polygon mesh can be done with the function
`CGAL::Polygon_mesh_processing::triangulate_faces()`
as shown in the example below.

\cgalExample{Polygon_mesh_processing/triangulate_faces_example.cpp}

\todo code : this example does not terminate

********************************************
\section PMPHoleFilling Hole Filling

This package provides algorithms for filling a hole that is either in a triangulated surface mesh
or defined by a sequence of points that describe a polyline.
The main steps of the algorithm are described in \cgalCite{Lipea2003FillingHoles} and can be summarized as follows.

First, a triangular patch for the hole is generated without introducing any new vertex. 
The patch minimizes a quality function evaluated for all possible triangular patches.
The quality function first minimizes the worst dihedral angle between patch triangles, then the total surface area as a tiebreaker.
Following the suggestions in \cgalCite{Zou2013AnAlgorithm}, the performance of the algorithm is significantly improved
by narrowing the search space to faces of a 3D Delaunay triangulation of the border vertices,
from all possible patches, while searching for the best patch. 

Then, the generated patch can be refined and faired using the meshing functions
`CGAL::Polygon_mesh_processing::refine()` and `CGAL::Polygon_mesh_processing::fair()`
described in Section \ref PMPMeshing.

\cgalFigureBegin{Mech_steps, mech_hole_horz.png}
Results of the main steps of the algorithm.
From left to right: the hole, after triangulation,
after triangulation and refinement,
after triangulation, refinement and fairing.
\cgalFigureEnd


\subsection HoleFillingAPI API

This package provides four functions for hole filling:
	- `triangulate_hole_polyline()` : given a sequence of points defining the hole, triangulates the hole.
	- `triangulate_hole()` : given a border halfedge defining the hole on a mesh, triangulates the hole.
	- `triangulate_and_refine_hole()` : in addition to `triangulate_hole()` the generated patch is refined.
	- `triangulate_refine_and_fair_hole()` : in addition to `triangulate_and_refine_hole()` the generated patch is also faired.

\subsection HFExamples Examples

\subsubsection HFExample_1 Triangulate a Polyline

The following example shows how to triangulate a hole described by an input polyline.

\cgalExample{Polygon_mesh_processing/triangulate_polyline_example.cpp}


\subsubsection HFExample_2 Hole Filling From the Border of the Hole

If the input polygon mesh has a hole or more than one hole, it is possible
to iteratively fill them by detecting border edges (i.e. with only
one incident face) along the evolution of the mesh.

Holes are filled one after the other, and the process stops when there is no border edge left.

This process is illustrated by the example below, where holes are
iteratively filled, refined and faired to get a nicely smooth mesh with no hole.


\cgalExample{Polygon_mesh_processing/hole_filling_example.cpp}

 \cgalFigureBegin{Triangulated_fork, fork.gif}
 Holes in fork model are filled with only triangulating.
 \cgalFigureEnd


***************************************
\section PMPPredicates Predicates

This packages provides some predicates to be evaluated with respect to a polygon mesh.

\subsection PMPSelIntersections Self Intersections

Self intersections can be detected and collected from a triangle mesh, using the two functions
`CGAL::Polygon_mesh_processing::is_self_intersecting()`
and `CGAL::Polygon_mesh_processing::self_intersections()`.

\cgalFigureBegin{SelfIntersections, selfintersections.png}
Results of detection of self intersections (right) on a triangle mesh (left).
\cgalFigureEnd

\subsubsection SIExample Self Intersections Example
\cgalExample{Polygon_mesh_processing/self_intersections_example.cpp}


\subsection PMPInsideTest Inside Test

The class `CGAL::Point_inside_polygon_mesh` provides a functor that tests whether a query point is 
inside, outside, or on the boundary of the domain described by a given closed polygon mesh.

\subsubsection InsideExample Inside Test Example
\cgalExample{Polygon_mesh_processing/point_inside_example.cpp}


****************************************
\section PMPOrientation Orientation

This package provides functions dealing with the orientation of faces in a closed polygon mesh.

The function `CGAL::Polygon_mesh_processing::is_outward_oriented()` checks whether
the polygon mesh is oriented such that the normals to faces are oriented towards the
outside of the domain bounded by the input polygon mesh.

In case the orientation is not satisfactory to the user, the function
`CGAL::Polygon_mesh_processing::reverse_face_orientations()` reverses the orientation
of halfedges around faces, and consequently of normals associated to faces.

See \ref PolygonSoupExample for an example of how these functions can be used.


****************************************
\section PMPRepairing Combinatorial Repairing 
*******************
\subsection Stitching

It happens that a polygon mesh has several edges and vertices that are duplicated.
For those edges and vertices, the connectivity of the mesh is incomplete, if not considered incorrect.

Stitching the borders of such a polygon mesh consists in two main steps.
First, border edges that are the same but duplicated are detected and associated together.
Then, they are "stitched" together so that the edges and vertices duplicates are removed
from the mesh, and each of these remaining edges is incident to exactly two faces.

The function \link stitching_grp `CGAL::Polygon_mesh_processing::stitch_borders()` \endlink
is available to perform this repairing operation.

\subsubsection StitchingExample Stitching Example

The following example shows how to apply the stitching operation to a simple quad mesh that
has duplicated border edges.

\cgalExample{Polygon_mesh_processing/stitch_borders_example.cpp}

*******************
\subsection DegenerateFaces Degenerate faces removal

Some degenerate faces may be part of a given triangle mesh.
A face is considered \e degenerate if two of its vertices are the same,
or if its three vertices are collinear.
The function
`CGAL::Polygon_mesh_processing::remove_degenerate_faces()` is able
to remove those faces and to fix the connectivity of the newly cleaned up mesh.

\subsubsection RemoveDegenerateExample Example

In the following example, the degenerate faces of a simple mesh containing
 some are removed, the connectivity is fixed, and the number of removed faces
 is displayed.

 \cgalExample{Polygon_mesh_processing/remove_degeneracies_example.cpp}


*******************
\subsection PolygonSoups Polygon Soups

When the faces of a mesh are given but the connectivity is not known,
we talk of a \e polygon \e soup.

Before being able to run any of this package algorithms on the so-called 
polygon soup, one should make sure that the polygons are consistently oriented.
To do so, this package provides the function
`CGAL::Polygon_mesh_processing::orient_polygon_soup()`.

Once the polygon soup is consistently oriented, the connectivity can be
brought together again, to build a polygon mesh.
The function `CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh()`
performs this mesh construction step.


\subsubsection PolygonSoupExample Polygon Soup Example

This example shows how to build a mesh from a polygon soup.
The first step is to get a soup of consistently oriented faces, before
reconstituting the connectivity.
In this example, some orientation tests are run on the output mesh to illustrate
Section \ref PMPOrientation.

\cgalExample{Polygon_mesh_processing/polygon_soup_example.cpp}



****************************************
\section PMPNormalComp Normals Computation

This package provides methods to compute normals to the polygon mesh.
The normal can be computed on a single face,
or estimated at a vertex, as the average of its incident faces normals.
These computations are done with :
- `CGAL::Polygon_mesh_processing::compute_face_normal()`
- `CGAL::Polygon_mesh_processing::compute_vertex_normal()`

When the normal to each simplex is intended to be used more than once,
it can be useful to avoid doing those computations again and again.
Functions that compute all the normals to faces, or at vertices, are also available :
- `CGAL::Polygon_mesh_processing::compute_face_normals()`
- `CGAL::Polygon_mesh_processing::compute_vertex_normals()`

Property maps are used to collect the computed normals.

Finally, a function that computes and collects all normals
to both faces and vertices is provided :
- `CGAL::Polygon_mesh_processing::compute_normals()`.

\subsection NormalsExample Normals Computation Example

The following example illustrates how to collect normals to faces
and vertices in property maps.

\cgalExample{Polygon_mesh_processing/compute_normals_example.cpp}


****************************************
\section PMPSlicer Slicer

The `CGAL::Polygon_mesh_slicer` is an operator that intersects a given triangulated surface
mesh with a plane. It computes the intersection as a polyline or a set of polylines since the intersection
can be made of more than one connected components.

\cgalFigureRef{SlicerFig} shows
the polylines returned by the slicing operation for a triangle mesh
and a plane for which a translation following the normal to the plane 
is performed.

\cgalFigureBegin{SlicerFig, slicer.png}
Slicing process. A triangle mesh (left) and the polylines
computed by the mesh slicer by intersecting the yellow plane
and translations of it with the mesh (right).
\cgalFigureEnd

\subsection SlicerExample Slicer Example

The example below illustrates how to use the mesh slicer for a given
triangle mesh and a plane. Two constructors are used in the example
for pedagogical purposes.

\cgalExample{Polygon_mesh_processing/mesh_slicer_example.cpp}

****************************************
\section PMPConnectedComponents Connected Components

This package provides functions to study the connected components of a
polygon mesh. The connected components can be either separated by border edges, or by
\e constraint edges.

First, the function `CGAL::Polygon_mesh_processing::connected_component()`
collects all the faces that belong to the same connected component as
the face that is given as a parameter.

Then, `CGAL::Polygon_mesh_processing::connected_components()`
collects all the connected components, and fills a property map
with the indices of the different connected components.

Finally, `CGAL::Polygon_mesh_processing::keep_largest_connected_components()`
allows the user to keep only the biggest connected components. This feature can
for example be useful for noisy data were small connected components
should be discarded in favour of major connected components.


\subsection CCExample Connected Components Example

The following example shows how to use the functions dealing with connected
components of a polygon mesh.
In particular, we provide an example for the optional parameter \c EdgeConstraintMap,
a property map that returns information about an edge being a \e constraint or not.
A \e constraint demarcates the border of a connected component, and prevents
the propagation of a connected component index to cross it.

\cgalExample{Polygon_mesh_processing/connected_components_example.cpp}

*/
} /* namespace CGAL */
